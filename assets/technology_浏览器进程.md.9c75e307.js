import{_ as a,c as e,o as t,O as o}from"./chunks/framework.0d343703.js";const u=JSON.parse('{"title":"浏览器进程","description":"","frontmatter":{"title":"浏览器进程","date":"2021-08-25T15:45:00.000Z","tags":["计算机基础"]},"headers":[],"relativePath":"technology/浏览器进程.md"}'),r={name:"technology/浏览器进程.md"},n=o('<h1 id="浏览器进程" tabindex="-1">浏览器进程 <a class="header-anchor" href="#浏览器进程" aria-label="Permalink to &quot;浏览器进程&quot;">​</a></h1><p><strong>chrome 为了节省内存的使用，限制了最多的进程数，最大进程数量由设备的内存和 CPU 能力决定，当达到这一限制时，新打开的 Tab 会共用之前同一个站点的渲染进程。</strong></p><h2 id="gui-渲染进程" tabindex="-1">GUI 渲染进程 <a class="header-anchor" href="#gui-渲染进程" aria-label="Permalink to &quot;GUI 渲染进程&quot;">​</a></h2><p>1、解析执行HTML文档，生成Dom树。</p><p>2、绘制CSS树。</p><h2 id="引擎进程" tabindex="-1">引擎进程 <a class="header-anchor" href="#引擎进程" aria-label="Permalink to &quot;引擎进程&quot;">​</a></h2><p>执行js脚本。</p><p>在浏览器渲染进程中必存在。</p><p>GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><h3 id="处理方法" tabindex="-1">处理方法 <a class="header-anchor" href="#处理方法" aria-label="Permalink to &quot;处理方法&quot;">​</a></h3><p>a) 减少 JavaScript 加载对 DOM 渲染的影响（将 JavaScript 代码的加载逻辑放在 HTML 文件的尾部，减少对渲染引擎呈现工作的影响； b) 避免重排，减少重绘（避免白屏，或者交互过程中的卡顿； c) 减少 DOM 的层级（可以减少渲染引擎工作过程中的计算量； d) 使用 requestAnimationFrame 来实现视觉变化（一般来说我们会使用 setTimeout 或 setInterval 来执行动画之类的视觉变化，但这种做法的问题是，回调将在帧中的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿）</p>',11),i=[n];function s(c,_,h,l,p,d){return t(),e("div",null,i)}const f=a(r,[["render",s]]);export{u as __pageData,f as default};
